Index: new/arch_init.c
===================================================================
--- new.orig/arch_init.c	2011-08-11 10:04:51.000000000 +0200
+++ new/arch_init.c	2011-08-11 10:10:04.000000000 +0200
@@ -251,9 +251,10 @@
 int ram_save_live(Monitor *mon, QEMUFile *f, int stage, void *opaque)
 {
     ram_addr_t addr;
-    uint64_t bytes_transferred_last;
     double bwidth = 0;
     uint64_t expected_time = 0;
+    static int64_t starttime = 0;
+    double timediff;
 
     if (stage < 0) {
         cpu_physical_memory_set_dirty_tracking(0);
@@ -293,10 +294,10 @@
             qemu_put_buffer(f, (uint8_t *)block->idstr, strlen(block->idstr));
             qemu_put_be64(f, block->length);
         }
+
+	starttime = qemu_get_clock_ns(rt_clock);
     }
 
-    bytes_transferred_last = bytes_transferred;
-    bwidth = qemu_get_clock_ns(rt_clock);
 
     while (!qemu_file_rate_limit(f)) {
         int bytes_sent;
@@ -308,8 +309,8 @@
         }
     }
 
-    bwidth = qemu_get_clock_ns(rt_clock) - bwidth;
-    bwidth = (bytes_transferred - bytes_transferred_last) / bwidth;
+    timediff = qemu_get_clock_ns(rt_clock) - starttime;
+    bwidth = bytes_transferred / timediff;
 
     /* if we haven't transferred anything this round, force expected_time to a
      * a very high value, but without crashing */
@@ -330,6 +331,10 @@
 
     qemu_put_be64(f, RAM_SAVE_FLAG_EOS);
 
+    if ((stage == 2) && (bytes_transferred > 2*ram_bytes_total())) {
+        return 1;
+    }
+
     expected_time = ram_save_remaining() * TARGET_PAGE_SIZE / bwidth;
 
     return (stage == 2) && (expected_time <= migrate_max_downtime());
